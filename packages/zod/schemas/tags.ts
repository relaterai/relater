import { TagColor } from '@repo/database';
import z from '../index';
import { getPaginationQuerySchema } from './misc';

export const SNAPSHOTS_MAX_PAGE_SIZE = 100;

export const getTagsQuerySchema = z
  .object({
    search: z
      .string()
      .optional()
      .describe('The search term to filter the tags by.'),
    name: z
      .string()
      .optional()
      .describe(
        'The name of the tag to filter by. Supports exact match or startsWith pattern matching.'
      ),
    ids: z
      .union([z.string(), z.array(z.string())])
      .transform((v) => (Array.isArray(v) ? v : v.split(',')))
      .optional()
      .describe('IDs of tags to filter by.'),
    sort: z
      .enum(['createdAt', 'updatedAt'])
      .optional()
      .describe('The field to sort by.'),
    withSnapshots: z
      .boolean()
      .optional()
      .refine((v) => !v || v === null, {
        message: 'Not implemented yet.',
      })
      .describe('Whether to include snapshots. Not implemented yet.'),
    withSnapshotsCount: z
      .union([z.boolean(), z.string()])
      .transform((val) => {
        if (typeof val === 'boolean') return val;
        return val === 'true';
      })
      .optional()
      .describe('Whether to include snapshots count.'),
    all: z
      .union([z.boolean(), z.string()])
      .transform((val) => {
        if (typeof val === 'boolean') return val;
        return val === 'true';
      })
      .optional()
      .describe('Whether to include all tags.'),
    pinned: z
      .union([z.boolean(), z.string()])
      .transform((val) => {
        if (typeof val === 'boolean') return val;
        return val === 'true';
      })
      .optional()
      .describe('Whether to include pinned tags.'),
  })
  .merge(getPaginationQuerySchema({ pageSize: SNAPSHOTS_MAX_PAGE_SIZE }));

// Schema to validate the request body when updating a tag
export const updateTagSchema = z.object({
  name: z.string().optional().describe('Name of the tag'),
  color: z.nativeEnum(TagColor).optional().describe('Color of the tag'),
  emoji: z.string().optional().describe('Emoji of the tag'),
  pinned: z.boolean().optional().describe('Whether to pin the tag'),
});

export const TagSchema = z.object({
  id: z.string(),
  name: z.string(),
  color: z.nativeEnum(TagColor),
  emoji: z.string(),
  pinned: z.boolean(),
  isAutoGenerated: z.boolean(),
  userId: z.string(),
  createdAt: z.date(),
  updatedAt: z.date(),
  _count: z
    .object({
      snapshots: z.number(),
    })
    .optional()
    .nullable()
    .describe('Number of snapshots associated with this tag'),
});

export const ResponseTagSchema = TagSchema.transform((tag) => ({
  ...tag,
  snapshotsCount: tag._count?.snapshots ?? 0,
  _count: undefined,
}));

export const disconnectTagsSchema = TagSchema.pick({
  id: true,
});

export const deleteTagSchema = TagSchema.pick({
  id: true,
}).extend({
  deleteSnapshot: z.boolean().optional(),
});

export const deleteTagQuerySchema = z.object({
  deleteSnapshot: z
    .union([z.boolean(), z.string()])
    .transform((val) => {
      if (typeof val === 'boolean') return val;
      return val === 'true';
    })
    .optional()
    .describe('Whether to delete related snapshots.'),
});
